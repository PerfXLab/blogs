<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blogs/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blogs/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blogs/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon-next2.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/apple-touch-icon-next2.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/apple-touch-icon-next2.png?v=5.1.4">


  <link rel="mask-icon" href="/blogs/images/apple-touch-icon-next2.png?v=5.1.4" color="#222">





  <meta name="keywords" content="OpenBLAS , 前端嵌入式智能系统+云端通用化 , HPC高性能计算 , FPGA , 计算机视觉 , 大数据产业 , AI, AI潜能 , AI+ , 人工智能 , perfxlab , PerfXLab , 澎峰科技 , 智能平台" />










<meta property="og:type" content="website">
<meta property="og:title" content="PerfXLab">
<meta property="og:url" content="https://github.com/PerfXLab/blogs/index.html">
<meta property="og:site_name" content="PerfXLab">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PerfXLab">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blogs/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/PerfXLab/blogs/"/>





  <title>PerfXLab</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blogs/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PerfXLab</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blogs/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blogs/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blogs/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blogs/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/PerfXLab/blogs/blogs/2018/05/17/ARMv8架构下程序运行时栈帧布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PerfXLab">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/17/ARMv8架构下程序运行时栈帧布局/" itemprop="url">ARMv8架构下程序运行时栈帧布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-17T11:14:30+08:00">
                2018-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ARMv8架构下程序运行时栈帧布局"><a href="#ARMv8架构下程序运行时栈帧布局" class="headerlink" title="ARMv8架构下程序运行时栈帧布局"></a>ARMv8架构下程序运行时栈帧布局</h2><p>结合ARM相关文档和在飞腾机器上使用gdb调试实际程序来研究ARM的指令和运行时栈帧布局。主要参考了三篇文档。</p>
<ol>
<li><p>Procedure Call Standard for the ARM 64-bit Architecture。参考其中的过程调用标准和运行时栈帧布局。</p>
</li>
<li><p>ARMv8 Instruction Set Overview。参考其中的指令概述。</p>
</li>
<li><p>ARM Compiler Migration and Compatibility Guide。参考其中ARM汇编与GNU汇编格式的比较。</p>
</li>
</ol>
<p>在文章1中，对ARM架构下运行时栈帧布局如图1所示。</p>
<img src="/blogs/2018/05/17/ARMv8架构下程序运行时栈帧布局/1.png">
<center>图1 ARM运行时栈帧布局</center><br><br><br><br><br>其中，FP(x29)寄存器保存栈帧地址，LR（x30）保存当前过程的返回地址。栈是从高地址向低地址生长。为验证图中的布局形式，在飞腾机器上安装gdb，通过调试一个示例程序，来研究ARM的指令特点和栈帧结构。示例程序如图2所示，函数TestParam定义了两个局部变量，分别为数组和标量类型。<br><br><br><br><img src="/blogs/2018/05/17/ARMv8架构下程序运行时栈帧布局/2.png"><br><br><center>图2 示例程序</center><br><br><br>使用gdb调试图2中代码所产生的程序，然后再反汇编函数TestParam，可以得到如下结果。<br><br><font color="#0000FF" size="2"><br>&emsp;=&gt; 0x0000000000400680 &lt;+0&gt;:stpx29, x30, [sp,#-64]!<br><br>   &emsp;&emsp;0x0000000000400684 &lt;+4&gt;:movx29, sp<br><br>   &emsp;&emsp;0x0000000000400688 &lt;+8&gt;:strw0, [x29,#28]<br><br>   &emsp;&emsp;0x000000000040068c &lt;+12&gt;:strw1, [x29,#24]<br><br>   &emsp;&emsp;0x0000000000400690 &lt;+16&gt;:strw2, [x29,#20]<br><br>   &emsp;&emsp;0x0000000000400694 &lt;+20&gt;:strw3, [x29,#16]<br><br>   &emsp;&emsp;0x0000000000400698 &lt;+24&gt;:adrpx0, 0x411000<a href="mailto:&#95;&#95;&#x6c;&#105;&#98;&#x63;&#95;&#x73;&#x74;&#97;&#x72;&#x74;&#x5f;&#x6d;&#97;&#105;&#x6e;&#64;&#103;&#x6f;&#116;&#x2e;&#x70;&#108;&#116;" target="_blank" rel="noopener">&#95;&#95;&#x6c;&#105;&#98;&#x63;&#95;&#x73;&#x74;&#97;&#x72;&#x74;&#x5f;&#x6d;&#97;&#105;&#x6e;&#64;&#103;&#x6f;&#116;&#x2e;&#x70;&#108;&#116;</a><br><br>   &emsp;&emsp;0x000000000040069c &lt;+28&gt;:addx0, x0, #0x38<br><br>   &emsp;&emsp;0x00000000004006a0 &lt;+32&gt;:ldrx1, [x0]<br><br>   &emsp;&emsp;0x00000000004006a4 &lt;+36&gt;:strx1, <br><br>   &emsp;&emsp;0x00000000004006a8 &lt;+40&gt;:movx1, #0x0&emsp;&emsp;&emsp;// #0<br><br>   &emsp;&emsp;0x00000000004006ac &lt;+44&gt;:ldrw1, [x29,#28]<br><br>   &emsp;&emsp;0x00000000004006b0 &lt;+48&gt;:ldrw0, [x29,#24]<br><br>   &emsp;&emsp;0x00000000004006b4 &lt;+52&gt;:addw0, w1, w0<br><br>   &emsp;&emsp;0x00000000004006b8 &lt;+56&gt;:strw0, [x29,#48]<br><br>   &emsp;&emsp;0x00000000004006bc &lt;+60&gt;:ldrw1, [x29,#20]<br><br>   &emsp;&emsp;0x00000000004006c0 &lt;+64&gt;:ldrw0, [x29,#16]<br><br>   &emsp;&emsp;0x00000000004006c4 &lt;+68&gt;:subw0, w1, w0<br><br>   &emsp;&emsp;0x00000000004006c8 &lt;+72&gt;:strw0, [x29,#52]<br><br>   &emsp;&emsp;0x00000000004006cc &lt;+76&gt;:ldrw1, [x29,#20]<br><br>   &emsp;&emsp;0x00000000004006d0 &lt;+80&gt;:ldrw0, [x29,#16]<br><br>   &emsp;&emsp;0x00000000004006d4 &lt;+84&gt;:addw0, w1, w0<br><br>   &emsp;&emsp;0x00000000004006d8 &lt;+88&gt;:strw0, [x29,#44]<br><br>   &emsp;&emsp;0x00000000004006dc &lt;+92&gt;:ldrw1, [x29,#48]<br><br>   &emsp;&emsp;0x00000000004006e0 &lt;+96&gt;:ldrw2, [x29,#52]<br><br>   &emsp;&emsp;0x00000000004006e4 &lt;+100&gt;:adrpx0, 0x400000<br><br>   &emsp;&emsp;0x00000000004006e8 &lt;+104&gt;:addx0, x0, #0x808<br><br>   &emsp;&emsp;0x00000000004006ec &lt;+108&gt;:ldrw3, [x29,#44]<br><br>   &emsp;&emsp;0x00000000004006f0 &lt;+112&gt;:bl0x400530&lt;printf@plt&gt;<br><br>   &emsp;&emsp;0x00000000004006f4 &lt;+116&gt;:adrpx0, 0x411000<a href="mailto:&#95;&#x5f;&#108;&#x69;&#x62;&#99;&#95;&#x73;&#x74;&#97;&#114;&#x74;&#x5f;&#109;&#97;&#x69;&#110;&#x40;&#x67;&#x6f;&#x74;&#x2e;&#112;&#x6c;&#x74;" target="_blank" rel="noopener">&#95;&#x5f;&#108;&#x69;&#x62;&#99;&#95;&#x73;&#x74;&#97;&#114;&#x74;&#x5f;&#109;&#97;&#x69;&#110;&#x40;&#x67;&#x6f;&#x74;&#x2e;&#112;&#x6c;&#x74;</a><br><br>   &emsp;&emsp;0x00000000004006f8 &lt;+120&gt;:addx0, x0, #0x38<br><br>   &emsp;&emsp;0x00000000004006fc &lt;+124&gt;:ldrx1, [x29,#56]<br><br>   &emsp;&emsp;0x0000000000400700 &lt;+128&gt;:ldrx0, [x0]<br><br>   &emsp;&emsp;0x0000000000400704 &lt;+132&gt;:eorx0, x1, x0<br><br>   &emsp;&emsp;0x0000000000400708 &lt;+136&gt;:cmpx0, xzr<br><br>   &emsp;&emsp;0x000000000040070c &lt;+140&gt;:b.eq0x400714&lt;TestParam+148&gt;<br><br>   &emsp;&emsp;0x0000000000400710 &lt;+144&gt;:bl0x400500&lt;__stack_chk_fail@plt&gt;<br><br>   &emsp;&emsp;0x0000000000400714 &lt;+148&gt;:ldpx29, x30,[sp],#64<br><br>   &emsp;&emsp;0x0000000000400718 &lt;+152&gt;:ret<br><br></font><br><br><center>该程序在运行时的栈帧如图3所示。</center>

<img src="/blogs/2018/05/17/ARMv8架构下程序运行时栈帧布局/3.png">
<p>以下是反汇编指令的解释以及其对栈中内容的影响。<br><br></p>
<font color="#0000FF" size="2"><br>&emsp;&emsp;=&gt; 0x0000000000400680 &lt;+0&gt;:stpx29, x30, [sp,#-64]!<br><br>&emsp;&emsp;0x0000000000400684 &lt;+4&gt;:movx29, sp<br></font>

<p>指令stp把一对值x29和x30放到SP-64的地址（7ffffff370）中去。此时的SP是旧SP，其值为7ffffff3b0。值得注意的是，这条语句同时完成了SP的自减运算，也就是执行之后，SP的值也变成了7ffffff370。第二条指令把FP的值设置为与SP的值相同。</p>
<font color="#0000FF" size="2"><br>  &emsp;&emsp;0x0000000000400688 &lt;+8&gt;:strw0, [x29,#28]<br><br>  &emsp;&emsp;0x000000000040068c &lt;+12&gt;:strw1, [x29,#24]<br><br>  &emsp;&emsp;0x0000000000400690 &lt;+16&gt;:strw2, [x29,#20]<br><br>  &emsp;&emsp;0x0000000000400694 &lt;+20&gt;:strw3, [x29,#16]<br><br></font><br>这4条指令把保存在参数传递寄存器中的4个参数保存到栈中。如图2中的w0, w1, w2, w3所示。<br><br><font color="#0000FF" size="2"><br>   &emsp;&emsp;0x0000000000400698 &lt;+24&gt;:adrpx0, 0x411000<a href="mailto:&#x5f;&#95;&#108;&#x69;&#98;&#99;&#95;&#x73;&#x74;&#x61;&#114;&#116;&#x5f;&#109;&#x61;&#105;&#110;&#64;&#103;&#x6f;&#116;&#x2e;&#112;&#108;&#116;" target="_blank" rel="noopener">&#x5f;&#95;&#108;&#x69;&#98;&#99;&#95;&#x73;&#x74;&#x61;&#114;&#116;&#x5f;&#109;&#x61;&#105;&#110;&#64;&#103;&#x6f;&#116;&#x2e;&#112;&#108;&#116;</a><br><br>   &emsp;&emsp;0x000000000040069c &lt;+28&gt;:addx0, x0, #0x38<br><br>   &emsp;&emsp;0x00000000004006a0 &lt;+32&gt;:ldrx1, [x0]<br><br>   &emsp;&emsp;0x00000000004006a4 &lt;+36&gt;:strx1, [x29,#56]<br><br>   &emsp;&emsp;0x00000000004006a8 &lt;+40&gt;:movx1, #0x0 &emsp;&emsp;// #0<br><br></font>

<p>这5条指令是用于安全保障的。因为函数TestParam中声明了一个数组，因此有受到缓冲区溢出攻击的危险。在其他平台下或者之前版本中，需要在编译时显式使用-fstack-protector选项，才会增加这样的安全保障指令。而在飞腾ARM配置的编译器中，默认就增加了。</p>
<p>其主要思路是在编译时生成一个随机化的值，如图中的_stack_guard保存在bss段中。在开始执行函数体时，把它从bss段中取出，放在栈的底部。然后执行函数。若有针对数组e的缓冲区溢出攻击，则_stack_guard就会被改写。在函数执行结束时，再把栈底部的值和bss段中的原始值相比较，若两者不同，就说明有攻击行为发生。</p>
<p>这5条指令的功能就是从bss段中把_stack_guard的值放到栈的底部。需要注意的是，在查找时使用了相对寻址指令adrp。</p>
<font color="#0000FF" size="2"><br>   &emsp;&emsp;0x00000000004006ac &lt;+44&gt;:ldrw1, [x29,#28]<br><br>   &emsp;&emsp;0x00000000004006b0 &lt;+48&gt;:ldrw0, [x29,#24]<br><br>   &emsp;&emsp;0x00000000004006b4 &lt;+52&gt;:addw0, w1, w0<br><br>   &emsp;&emsp;0x00000000004006b8 &lt;+56&gt;:strw0, [x29,#48]<br><br>   &emsp;&emsp;0x00000000004006bc &lt;+60&gt;:ldrw1, [x29,#20]<br><br>   &emsp;&emsp;0x00000000004006c0 &lt;+64&gt;:ldrw0, [x29,#16]<br><br>   &emsp;&emsp;0x00000000004006c4 &lt;+68&gt;:subw0, w1, w0<br><br>   &emsp;&emsp;0x00000000004006c8 &lt;+72&gt;:strw0, [x29,#52]<br><br></font>

<p>这8条指令是使用形式参数进行运算，并把结果保存在数组中。数组中只有两个元素，被放置在靠近栈底的位置。</p>
<font color="#0000FF" size="2"><br>   &emsp;&emsp;0x00000000004006cc &lt;+76&gt;:ldrw1, [x29,#20]<br><br>   &emsp;&emsp;0x00000000004006d0 &lt;+80&gt;:ldrw0, [x29,#16]<br><br>   &emsp;&emsp;0x00000000004006d4 &lt;+84&gt;:addw0, w1, w0<br><br>   &emsp;&emsp;0x00000000004006d8 &lt;+88&gt;:strw0, [x29,#44]<br></font>

<p>这4条指令的作用是计算出f的值，并把它保存到栈中。</p>
<font color="#0000FF" size="2"><br>   &emsp;&emsp;0x00000000004006dc &lt;+92&gt;:ldrw1, [x29,#48]<br><br>   &emsp;&emsp;0x00000000004006e0 &lt;+96&gt;:ldrw2, [x29,#52]<br><br>   &emsp;&emsp;0x00000000004006e4 &lt;+100&gt;:adrpx0, 0x400000<br><br>   &emsp;&emsp;0x00000000004006e8 &lt;+104&gt;:addx0, x0, #0x808<br><br>   &emsp;&emsp;0x00000000004006ec &lt;+108&gt;:ldrw3, [x29,#44]<br><br>   &emsp;&emsp;0x00000000004006f0 &lt;+112&gt;:bl0x400530 &lt;printf@plt&gt;<br></font>

<p>这6条指令是负责准备参数寄存器x0、w1、w2和w3的值，并调用printf。x0中存放的是指向格式字符串的指针。</p>
<font color="#0000FF" size="2"><br>   &emsp;&emsp;0x00000000004006f4 &lt;+116&gt;:adrpx0, 0x411000<a href="mailto:&#x5f;&#95;&#108;&#105;&#98;&#x63;&#x5f;&#x73;&#x74;&#97;&#114;&#116;&#95;&#x6d;&#x61;&#105;&#x6e;&#64;&#x67;&#x6f;&#x74;&#x2e;&#x70;&#108;&#x74;" target="_blank" rel="noopener">&#x5f;&#95;&#108;&#105;&#98;&#x63;&#x5f;&#x73;&#x74;&#97;&#114;&#116;&#95;&#x6d;&#x61;&#105;&#x6e;&#64;&#x67;&#x6f;&#x74;&#x2e;&#x70;&#108;&#x74;</a><br><br>   &emsp;&emsp;0x00000000004006f8 &lt;+120&gt;:addx0, x0, #0x38<br><br>   &emsp;&emsp;0x00000000004006fc &lt;+124&gt;:ldrx1, [x29,#56]<br><br>   &emsp;&emsp;0x0000000000400700 &lt;+128&gt;:ldrx0, [x0]<br><br>   &emsp;&emsp;0x0000000000400704 &lt;+132&gt;:eorx0, x1, x0<br><br>   &emsp;&emsp;0x0000000000400708 &lt;+136&gt;:cmpx0, xzr<br><br>   &emsp;&emsp;0x000000000040070c &lt;+140&gt;:b.eq0x400714 &lt;TestParam+148&gt;<br><br>   &emsp;&emsp;0x0000000000400710 &lt;+144&gt;:bl0x400500 &lt;__stack_chk_fail@plt&gt;<br></font>

<p>这8条指令是比较_stack_guard的值与存放在bss段中的值是否相等，若相等，在跳到400714，继续执行TestParam函数，否则跳到_stack_chk_fail函数，处理缓冲区溢出发生的情况。</p>
<font color="#0000FF" size="2"><br>   &emsp;&emsp;0x0000000000400714 &lt;+148&gt;:ldpx29, x30, [sp],#64<br><br>   &emsp;&emsp;0x0000000000400718 &lt;+152&gt;:ret<br><br></font>

<p>这2条指令从栈中恢复x29和x30的值，并返回。需要注意的是ldp指令执行之后，sp的值自动增加了64。<br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<ul>
<li style="list-style: none"><input type="checkbox"> 作者：马晓东</li>
</ul>
<center> <img src="/blogs/2018/05/17/ARMv8架构下程序运行时栈帧布局/ewm.jpg"> </center>


<h4 id="欢迎关注微信公众号“perfxlab卧谈会”"><a href="#欢迎关注微信公众号“perfxlab卧谈会”" class="headerlink" title="欢迎关注微信公众号“perfxlab卧谈会”"></a><center>欢迎关注微信公众号“<font color="#0000FF" size="2">perfxlab卧谈会</font>”</center></h4><p><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/PerfXLab/blogs/blogs/2018/05/17/Git常用命令总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blogs/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PerfXLab">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blogs/2018/05/17/Git常用命令总结/" itemprop="url">Git常用命令总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-17T11:14:30+08:00">
                2018-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>git作为一个经典的代码管理工具，即使在实际当中可能很少会遇到复杂情况，但对于这个几乎我们天天打交道的工具，我们也需要去学习个大概，知道目前处于什么样的问题场景，从而清楚搜哪些东西。让这个随用随查，不会沦落到技能的反面。</p>
<p>为了不显得在学习的过程中过于乏味与无聊，我找到learngitbranching这个好玩儿的闯关游戏，以练习的形式学习git相关的知识。下面是记录在闯关过程中的知识要点记录。</p>
</blockquote>
<h1 id="1-Git-branch"><a href="#1-Git-branch" class="headerlink" title="1. Git branch"></a>1. Git branch</h1><p>git branch常见有三种用法。</p>
<p>用法1：创建并切换到名为bugFix的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch bugFix</span><br><span class="line"></span><br><span class="line">git checkout bugFix</span><br><span class="line"></span><br><span class="line">==*上面两句还可以用下面一句代替==</span><br><span class="line"></span><br><span class="line">git checkout ‐b bugFix</span><br></pre></td></tr></table></figure>
<p>用法2：强制修改分支位置，如将 master 分支强制指向 HEAD 的第 3 级父提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch master HEAD~3</span><br></pre></td></tr></table></figure>
<p>用法3：设置远程追踪的本地分支，如让本地分支 foo 跟踪远程 origin/master 分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch ‐u o/master foo</span><br><span class="line"></span><br><span class="line">==*若当前在 foo 分支上，可以省略 foo ，如下==</span><br><span class="line"></span><br><span class="line">git branch ‐u o/master</span><br></pre></td></tr></table></figure>
<h1 id="2-合并代码"><a href="#2-合并代码" class="headerlink" title="2. 合并代码"></a>2. 合并代码</h1><h2 id="2-1-方式一：merge"><a href="#2-1-方式一：merge" class="headerlink" title="2.1 方式一：merge"></a>2.1 方式一：merge</h2><p>在base分支上（一般是master）去合并其他功能分支，比方master要合并bugFix分支。则前提当前要在master分支上，然后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure>
<p>合并结束后，bugFix分支没有用了就可以被删除。当然也可以再在bugFix分支上去合并master分支，此时实际上是bugFix指向的HEAD快速移动（fast forward）到了master分支。</p>
<h2 id="2-2-方式二：rebase"><a href="#2-2-方式二：rebase" class="headerlink" title="2.2 方式二：rebase"></a>2.2 方式二：rebase</h2><p>git rebase是另一种合并代码的命令。Rebase 的优势就是可以创造更线性的提交历史。同样用master分支合并bugFix分支，但是此时先要在bugFix分支上，按git rebase的字面意思理解：“以某个分支重新作为base”，那么rebase后的分支名应是父分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix</span><br><span class="line"></span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<p>rebase还可以合并特性分支到主分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase BRANCH_BASE BRANCH_CHILD</span><br><span class="line"></span><br><span class="line">==*如: git rebase master feature_conv1x==</span><br></pre></td></tr></table></figure>
<h2 id="2-3-方式三：cherry-pick"><a href="#2-3-方式三：cherry-pick" class="headerlink" title="2.3 方式三：cherry-pick"></a>2.3 方式三：cherry-pick</h2><p>等同于 rebase ­i 。但是二者的区别是是否知道提交名，若不知道提交名则通过相对引用使用 rebase ­i 命令去合并。</p>
<p>使用前提是当前位于父分支的位置处，cherry-pick的参数是要合并的提交名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git cherry‐pick C2 C4</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"></span><br><span class="line">git cherry‐pick C4</span><br></pre></td></tr></table></figure>
<h1 id="3-移动位置"><a href="#3-移动位置" class="headerlink" title="3. 移动位置"></a>3. 移动位置</h1><h2 id="3-1-HEAD与指向"><a href="#3-1-HEAD与指向" class="headerlink" title="3.1 HEAD与指向"></a>3.1 HEAD与指向</h2><p>我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<p><em>如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic­ref HEAD 查看它的指向。</em></p>
<p>默认情况下，HEAD指向分支名，分支名指向最近一次提交，如若最常见的情景是：</p>
<pre><code>HEAD ‐&gt; master ‐&gt; C1
</code></pre><p>即当前 HEAD 指向 master 分支，而当前 master 分支的最近一次提交指向 C1。</p>
<p>若 checkout 到某个提交 C1 ，那么当前 HEAD 就指向某个提交 C1 ，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEAD ‐&gt; C1</span><br></pre></td></tr></table></figure>
<h2 id="3-2-引用操作符"><a href="#3-2-引用操作符" class="headerlink" title="3.2 引用操作符"></a>3.2 <strong><em>引用操作符</em></strong></h2><h3 id="3-2-1-功能一：移动位置"><a href="#3-2-1-功能一：移动位置" class="headerlink" title="3.2.1 功能一：移动位置"></a>3.2.1 功能一：移动位置</h3><p>●使用 ^向上移动 1 个提交记录。</p>
<ul>
<li>master^* 相当于“ master 的父节点”。 master^^ 是 master 的第二个父节点。</li>
</ul>
<p>●使用 <em>~<num></num></em> 向上移动多个提交记录。如 ~3</p>
<p>引用操作符也可以连着写，比方操作 git checkout HEAD~2; git checkout HEAD^; git checkout HEAD~4 可以等效写为： git checkout HEAD~2^~4 。</p>
<blockquote>
<p>操作符 ^ 与 ~符一样，后面也可以跟一个数字。</p>
<p>但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>
<p>Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。</p>
</blockquote>
<h3 id="3-2-2-功能二：-切换主父节点和-2切换副父节点"><a href="#3-2-2-功能二：-切换主父节点和-2切换副父节点" class="headerlink" title="3.2.2 功能二：^切换主父节点和 ^2切换副父节点"></a>3.2.2 功能二：^切换主父节点和 ^2切换副父节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master^</span><br></pre></td></tr></table></figure>
<p>对于merge合并的提交记录。如果不加数字修改符直接检出 master^ ，会回到第一个父提交记录。切换副父节点的提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master^2</span><br></pre></td></tr></table></figure>
<p>强制修改分支位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch master HEAD~3</span><br></pre></td></tr></table></figure>
<p>命令会将 master 分支强制指向 HEAD 的第 3 级父提交。</p>
<h1 id="4-撤销变更"><a href="#4-撤销变更" class="headerlink" title="4. 撤销变更"></a>4. 撤销变更</h1><p>● git reset：本地分支中使用（对远程分支是无效的），如 git reset HEAD~1 。reset后， reset 消失掉的变更还在，但是处于未加入暂存区状态。</p>
<p>● git revert：不仅撤销更改，而且可以提交给远程。git revert HEAD 会撤销到当前HEAD的父节点，revert顾名思义：“翻转”，虽然后面接的是HEAD，但是“翻转HEAD”即当前节点的父节点。</p>
<h1 id="5-移动提交记录"><a href="#5-移动提交记录" class="headerlink" title="5. 移动提交记录"></a>5. 移动提交记录</h1><p>开发人员想把这个提交放到这里，那个提交放到刚才那个提交的后面。</p>
<img src="/blogs/2018/05/17/Git常用命令总结/1.png">
<p>这里有一个仓库，我们想将side 分支上的工作复制到 master 分支，你立刻想到了之前学过的rebase 了吧？</p>
<p>除了rebase，还有两种实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">● git cherry-pick &lt;提交号&gt;...</span><br><span class="line"></span><br><span class="line">● git rebase -i</span><br></pre></td></tr></table></figure>
<h2 id="5-1-方法一：知道提交名的cherry-pick"><a href="#5-1-方法一：知道提交名的cherry-pick" class="headerlink" title="5.1 方法一：知道提交名的cherry-pick"></a>5.1 方法一：知道提交名的cherry-pick</h2><p>先用cherry-pick：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry‐pick C2 C4</span><br></pre></td></tr></table></figure>
<img src="/blogs/2018/05/17/Git常用命令总结/2.png">
<h2 id="5-2-方法二：不知提交名的交互式-rebase"><a href="#5-2-方法二：不知提交名的交互式-rebase" class="headerlink" title="5.2 方法二：不知提交名的交互式 rebase"></a>5.2 方法二：不知提交名的交互式 rebase</h2><p>当知道提交记录的哈希值时, 用 cherry-pick 再好不过了。但是如果不清楚你想要的提交记录的哈希值呢? 可以利用交互式的 rebase。尤其是想从一系列的提交记录中找到想要的记录。</p>
<p>交互式 rebase 指的是使用带参数 ­­interactive 的 rebase 命令, 简写为 ­i。</p>
<p>当 rebase UI界面打开时, 你能做3件事:</p>
<p>● 调整提交记录的顺序（通过鼠标拖放来完成）</p>
<p>● 删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录）</p>
<p>● 合并提交。 它允许你把多个提交记录合并成一个。</p>
<img src="/blogs/2018/05/17/Git常用命令总结/3.png">
<p>当执行下面命令时会出现一个交互对话框。对提交记录做个排序（当然你也可以删除某些提交）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase ‐i HEAD~4</span><br></pre></td></tr></table></figure>
<p>Git 严格按照你在对话框中指定的方式进行了复制。执行后得到如下结果：</p>
<img src="/blogs/2018/05/17/Git常用命令总结/4.png">
<h1 id="6-标记和查找"><a href="#6-标记和查找" class="headerlink" title="6. 标记和查找"></a>6. 标记和查找</h1><h2 id="6-1-用Tag标记提交"><a href="#6-1-用Tag标记提交" class="headerlink" title="6.1 用Tag标记提交"></a>6.1 用Tag标记提交</h2><p>分支很容易被改变，大部分分支还只是临时的，并且还一直在变。Git 的 tag 永久地将某个特定的提交命名为里程碑，也可以像分支一样引用了。不会随着新的提交而移动不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<p>下面建立一个标签，指向提交记录 C1，表示1.0 版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1 C1</span><br></pre></td></tr></table></figure>
<p>若不指定提交记录，Git 会用当前 HEAD 所指向的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.2 用Describe查找最近的标记记录</span><br></pre></td></tr></table></figure>
<p>由于标签 tag 在代码库中起着“锚点”的作用，Git 专门设计了用来描述离你最近锚点（也就是标签）的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure>
<p><ref> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（ HEAD ）。</ref></p>
<p>找某个提交记录可用 git bisect （一个查找产生 Bug 的提交记录的指令）。</p>
<p>它输出的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure>
<p>● tag 表示的是离 ref 最近的标签</p>
<p>● numCommits 是表示这个 ref 与tag 相差有多少个提交记录</p>
<p>● hash 表示的是你所给定的ref 所表示的提交记录哈希值的前几位</p>
<h1 id="7-远程操作"><a href="#7-远程操作" class="headerlink" title="7. 远程操作"></a>7. 远程操作</h1><h2 id="7-1-Git-Clone"><a href="#7-1-Git-Clone" class="headerlink" title="7.1 Git Clone"></a>7.1 Git Clone</h2><p>git clone 命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从 github.com）。</p>
<p>远程分支的一个特别属性：在检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>
<p>远程分支的前面的 origin/是远程仓库的意思。当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了。</p>
<p>远程分支也有命名规范，如远程仓库名为 origin 分支名为 master 的远程分支为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;remote name&gt;/&lt;branch name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-Git-Fetch"><a href="#7-2-Git-Fetch" class="headerlink" title="7.2 Git Fetch"></a>7.2 Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。 git fetch 完成了仅有的但是很重要的两步：</p>
<p>●从远程仓库下载本地仓库中缺失的提交记录</p>
<p>●更新本地的远程分支指针(如 o/master )</p>
<p>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>
<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你最后一次与它通信时的状态， git fetch就是你与远程仓库通信的方式了。 git fetch 通常通过互联网（使用 http:// 或 git:// 协议) 与远程仓库通信。</p>
<p>git fetch 不会改变本地仓库的状态（把远程仓库更新下载到了本地的origin仓库，比方对应的本地的远程主分支即origin/master）。它不会更新你的 master 分支，也不会修改你磁盘上的文件。</p>
<blockquote>
<p>Note: 理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。<br>所以可以将 git fetch 理解为单纯的下载操作。</p>
</blockquote>
<h2 id="7-3-Git-Pull"><a href="#7-3-Git-Pull" class="headerlink" title="7.3 Git Pull"></a>7.3 Git Pull</h2><p>当远程分支中有新的提交时，可以像合并本地分支那样来执行以下命令合并远程分支：</p>
<p> ● git cherry­pick o/master</p>
<p> ● git rebase o/master</p>
<p> ● git merge o/master</p>
<p> ● 等等</p>
<p>实际上，先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了 git pull 命令来完成这两个操作。等同于 fetch 、 merge 依次执行的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch; git merge o/master</span><br></pre></td></tr></table></figure>
<p>我们用 fetch 下载了远端最新（而本地没有）的提交, 然后通过 git merge o/master 合并了这一提交记录。这两句等同于 git pull 。</p>
<h2 id="7-4-Git-Push"><a href="#7-4-Git-Push" class="headerlink" title="7.4 Git Push"></a>7.4 Git Push</h2><p>git push 上传自己分享内容与 git pull 下载他人的分享刚好相反。 git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。</p>
<p>注意：git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。*</p>
<p>常见使用场景：</p>
<p>”假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。“</p>
<p>这种情况下, git push 就不知道该如何操作了。如果你执行 git push ，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，异或由于你的提交已经过时而直接忽略你的提交？</p>
<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>
<p>解决这个问题就需要使你的工作基于最新的远程分支。有许多方法做到这一点呢，不过最直接的方法就是通过rebase 调整你的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch; git rebase o/master; git push</span><br><span class="line"></span><br><span class="line"># 等同于下面这句命令</span><br><span class="line"></span><br><span class="line">git pull ‐‐rebase; git push</span><br></pre></td></tr></table></figure>
<p>或者用merge操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git fetch; git merge o/master; git push</span><br><span class="line"></span><br><span class="line"># 等同于下面这句命令</span><br><span class="line"></span><br><span class="line">git pull; git push</span><br></pre></td></tr></table></figure>
<h1 id="8-跟踪远程分支"><a href="#8-跟踪远程分支" class="headerlink" title="8. 跟踪远程分支"></a>8. 跟踪远程分支</h1><p>Git 好像知道 master 与 o/master 是相关的。这种关联在以下两种情况下可以清楚地得到展示：</p>
<p>● pull 操作时, 提交记录会被先下载到 o/master 上，之后再合并到本地的 master 分支。隐含的合并目标由这个关联确定的。</p>
<p>● push 操作时, 我们把工作从 master 推到远程仓库中的 master 分支(同时会更新远程分支 o/master ) 。这个推送的目的地也是由这种关联确定的！</p>
<h2 id="8-1-远程跟踪"><a href="#8-1-远程跟踪" class="headerlink" title="8.1 远程跟踪"></a>8.1 远程跟踪</h2><p>master 和 origin/master 的关联关系就是由分支的“remote tracking”属性决定的。 master 被设定为跟踪origin/master —— 这意味着为 master 分支指定了推送的目的地以及拉取后合并的目标。</p>
<p>当克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 origin/master ）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 master 。</p>
<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以用 git branch ­a 查看本地和远程仓库中所有的分支（如果你好奇心很强的话）。</p>
<p>这样做对于本地仓库和远程仓库来说，都是最佳选择。这也解释了为什么会在克隆的时候会看到下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;master&quot; set to track remote branch &quot;origin/master&quot;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-跟踪任意分支"><a href="#8-2-跟踪任意分支" class="headerlink" title="8.2 跟踪任意分支"></a>8.2 跟踪任意分支</h2><p>可以让任意分支跟踪 origin/master , 然后该分支会像 master 分支一样得到隐含的 push 目的地以及 merge 的目标。下面介绍两种方法：</p>
<p>方法1：git checkout -b</p>
<p>通过远程分支检出一个新的分支，本地创建 totallyNotMaster 分支，并让它跟踪远程分支 origin/master ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout ‐b totallyNotMaster origin/master</span><br></pre></td></tr></table></figure>
<p>方法2：git branch -u</p>
<p>让本地分支 foo 跟踪远程 origin/master 分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch ‐u o/master foo</span><br><span class="line"></span><br><span class="line"># 若当前在 foo 分支上, 还可以省略 foo</span><br><span class="line"></span><br><span class="line">git branch ‐u o/master</span><br></pre></td></tr></table></figure>
<h2 id="8-3-Git-Push-的两个参数"><a href="#8-3-Git-Push-的两个参数" class="headerlink" title="8.3 Git Push 的两个参数"></a>8.3 Git Push 的两个参数</h2><h3 id="8-3-1-Push-到远程仓库"><a href="#8-3-1-Push-到远程仓库" class="headerlink" title="8.3.1 Push 到远程仓库"></a>8.3.1 Push 到远程仓库</h3><p>注：本小节使用场景基本没有，作为了解。</p>
<p>指定 push 的目的地的语法是， <place> 参数稍后会更深入其中的细节：</place></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;place&gt;</span><br><span class="line"></span><br><span class="line"># 如下面的一个简单例子</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>简单例子的这个命令翻译过来就是：切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</p>
<p>它实际就是要同步本地和远程同一个place（即分支）的两个仓库的 HEAD 位置。默认情况下不加 ，即 origin，是因为 Git 默认给你隐式给你加上了，默认也会认为是提交给远程，即 origin 。大多数情况下不加 参数也没有什么问题。</p>
<p>但个别情况下，也有例外，举出下面的例子：</p>
<img src="/blogs/2018/05/17/Git常用命令总结/5.png">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout C0; git push origin master</span><br></pre></td></tr></table></figure>
<p>当检出到 C0 位置时，远程和本地分支都有早期 C0 位置的代码，本地的最新提交是 C2，想要在 C0 的位置处推送C2 位置的代码因为指定了 master 分支，推向 origin 远端，那么 Git 就会搜寻本地master 分支的所有提交与origin 远端的 master 分支比较，并将新提交上传。</p>
<img src="/blogs/2018/05/17/Git常用命令总结/6.png">
<p>简而言之，通过指定参数, 远程仓库中的 master 分支得到了更新。如果不指定参数会发生什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### git checkout C0; git push</span><br></pre></td></tr></table></figure>
<p>因为所检出的 HEAD 没有指定 参数，没有跟踪任何分支，所以什么也没发生。当然这种HEAD位置不指向分支的使用场景很少见，一般使用中也不会出现这种情况。本例只作为一个对 git push 命令 参数的学习。</p>
<h3 id="8-3-2-Push-到分支"><a href="#8-3-2-Push-到分支" class="headerlink" title="8.3.2 Push 到分支"></a>8.3.2 Push 到分支</h3><p>如果想让 push 的来源分支和去向分支的名称不同，要同时为源和目的地指定 <place> ，只需用冒号 : 将二者连起来就可以了：</place></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;source&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure>
<p>或 参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 foo ， foo^ 或者 HEAD~1 ），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin foo^:master</span><br></pre></td></tr></table></figure>
<p>这是个另人困惑的命令，但是它确实是可以运行的 —— Git 将 foo^ 解析为一个位置，上传所有未被包含到远程仓库里 master 分支中的提交记录。</p>
<p>如果要推送到的目的分支不存在，Git 会在远程仓库中根据你提供的名称帮你创建这个分支！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master:newBranch</span><br></pre></td></tr></table></figure>
<h2 id="8-4-Git-fetch-的参数"><a href="#8-4-Git-fetch-的参数" class="headerlink" title="8.4 Git fetch 的参数"></a>8.4 Git fetch 的参数</h2><p>git push 的 <place> ，还有用冒号分隔的 refspecs（ <source>:<destination>）。 这些参数也可以用于 git fetch 。push 与 fetch 二者的概念相同，fetch 是下载，而非上传。</destination></place></p>
<p>下面的命令中用到了 参数， Git 会到远程仓库的 foo 分支上，然后获取所有本地不存在的提交，放到本地的o/foo 上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br></pre></td></tr></table></figure>
<p>只下载了远程仓库中 foo 分支中的最新提交记录，并更新了本地仓库的 origin/foo，注意：不是本地的 foo 分支，而是本地的远程分支 origin/foo。</p>
<p>如果 git fetch 没有 参数，它会下载所有的提交记录到各个远程分支。</p>
<p>此外，我们也可以指定 <source>:<destination> ，但很少这么用。</destination></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo~1:bar</span><br></pre></td></tr></table></figure>
<p>Git 将 foo~1 解析成一个 origin 仓库的位置，然后将那些提交记录下载到了本地的 bar 分支（一个本地分支，但我认为这里是本地的远程分支，即 origin/bar）上。注意由于我们指定了目标分支， foo 和 o/foo 都没有被更新。</p>
<p>如果执行命令前目标分支不存在，假设没有 bar 分支。那么 Git 会在 fetch 前自己创建立本地分支, 就像是 Git 在push 时，如果远程仓库中不存在目标分支，会自己建立一样。</p>
<h2 id="8-5-参数"><a href="#8-5-参数" class="headerlink" title="8.5 参数"></a>8.5 参数</h2><p>Git 有两种关于 <source> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 source ，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>
<p>● git push origin :side</p>
<p>● git fetch origin :bugFix</p>
<p>如果 push 的 source 为空，到远程仓库，它会删除远程仓库中的 foo 分支！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :foo</span><br></pre></td></tr></table></figure>
<p>如果 fetch 的 source 为空，到本地仓库，它会在本地创建一个 bar 分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin :bar</span><br></pre></td></tr></table></figure>
<h2 id="8-6-Git-pull-的参数"><a href="#8-6-Git-pull-的参数" class="headerlink" title="8.6 Git pull 的参数"></a>8.6 Git pull 的参数</h2><p>git pull 到头来就是 fetch 后再 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。以下命令在 Git 中是等效的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># case 1</span><br><span class="line"></span><br><span class="line">git pull origin foo</span><br><span class="line"></span><br><span class="line"># 等效于</span><br><span class="line"></span><br><span class="line">git fetch origin foo; git merge o/foo</span><br><span class="line"></span><br><span class="line"># case 2</span><br><span class="line"></span><br><span class="line">git pull origin bar~1:bugFix</span><br><span class="line"></span><br><span class="line"># 等效于</span><br><span class="line"></span><br><span class="line">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure>
<p>pull 也可以用 source:destination 参数。</p>
<img src="/blogs/2018/05/17/Git常用命令总结/7.png">
<p>比方上图场景，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master:foo</span><br></pre></td></tr></table></figure>
<img src="/blogs/2018/05/17/Git常用命令总结/8.png">
<p>因为本地没有 foo 分支。那么，该命令先在本地创建了一个叫 foo 的分支，从远程仓库中的 master 分支中下载提交记录，并合并到 foo ，然后又因为当前在 bar 分支上，所以会再 merge 到我们的当前检出的分支 bar 上。</p>
<p><br></p>
<p><br><br><br></p>
<p><br></p>
<ul>
<li style="list-style: none"><input type="checkbox"> 作者：袁帅 王建章</li>
</ul>
<center> <img src="/blogs/2018/05/17/Git常用命令总结/ewm.jpg"> </center>


<h4 id="欢迎关注微信公众号“perfxlab卧谈会”"><a href="#欢迎关注微信公众号“perfxlab卧谈会”" class="headerlink" title="欢迎关注微信公众号“perfxlab卧谈会”"></a><center>欢迎关注微信公众号“<font color="#0000FF" size="2">perfxlab卧谈会</font>”</center></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/blogs/images/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blogs/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blogs/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>






  








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blogs/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blogs/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blogs/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blogs/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/blogs/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blogs/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/blogs/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
